---
layout: post
title: 'Parsing ZIP Files: How Bad Could it Be?'
author: Luke Bemish
---

I recently had reason to parse some basic information out of ZIP files. How hard could it be, I thought? Turns out, it can be awfully complicated and at times ambiguous.

## The spec

To start with, there're a few different specifications for ZIP files floating around. PKWARE publishes their "APPNOTE" describing the file format, with the most recent
available version being [6.3.10](https://pkwaredownloads.blob.core.windows.net/pem/APPNOTE-6.3.10.txt), intended to ensure the interoperability of ZIP files across different
implementations. There's also the [Info-ZIP Application Note](http://www.info-zip.org/doc/appnote-19970311-iz.zip), upon which Java's utilities for reading ZIP files, and by proxy `.jar` files, is based. The Info-ZIP note that Java references is based on an older version of PKWARE's appnote from 1996 that has been, to quote the disclaimer at the front, "unofficially corrected and extended". I figured I would start with PKWARE's APPNOTE, since the two don't seem to differ that much in the parts I was interested in.

## The file structure

First thing's first, the piece of a ZIP file that identifies it as such is the end of central directory header (EOCD record):

> A ZIP file MUST contain an "end of central directory record". [...]
> A ZIP file MUST have only one "end of central directory record". Other 
> records defined in this specification MAY be used as needed to support 
> storage requirements for individual ZIP files

In fact, you can have an "empty" ZIP file that contains nothing but the EOCD record. Then, there're a few other headers that make up a zip file.
Including just the core records, the general structure of a zip file should look something like:

```
[local file header 1]
[file data 1]
...
[local file header n]
[file data n]
[central directory header 1]
...
[central directory header n]
[end of central directory record]
```

There are, of course, some extra records that could pop up: various ones for handling encryption, the ZIP64 extension, and various
other use cases. For what I was doing, I didn't foresee having to handle any of this (my goal was to pull out specific information from the ZIP,
not to build a full-fledged ZIP utility, after all).

Let's take a look at the EOCD record:

```
end of central dir signature    4 bytes  (0x06054b50)
number of this disk             2 bytes
number of the disk with the
start of the central directory  2 bytes
total number of entries in the
central directory on this disk  2 bytes
total number of entries in
the central directory           2 bytes
size of the central directory   4 bytes
offset of start of central
directory with respect to
the starting disk number        4 bytes
.ZIP file comment length        2 bytes
.ZIP file comment       (variable size)
```

Hmm... we get a magic number, some information to locate the rest of the central directory, and... wait what?

```
.ZIP file comment length        2 bytes
.ZIP file comment       (variable size)
```

Ooookay. So the EOCD record, which is what tells us that this file is a ZIP file to begin with, can't just be located by looking for the magic number at a fixed offset from the end, since it ends with a variable-length field. This looks fun!

## Reading records

With this in mind, there are a few naive ways to start parsing a ZIP: do I parse from the front, looking at the magic numbers for the various records as I go? Or do I start from the end, find the EOCD record, and then locate the other records from there?

The format seems to force my hand here to a degree; ZIP files are allowed to be "self-extracting", including code to extract them for some platform. For a file to be 
self-extracting and still be a valid ZIP file, you would need to shove some executable logic at the front of the file before any of the ZIP records start:

```
[executable stub]
[files]
[central directory]
[EOCD]
```

And there's nothing to say that that executable stub couldn't contain byte sequences identical to the magic numbers for ZIP records. In other words, you can have junk data
present at the start of a ZIP file and still have it be a valid ZIP file.

At some level, this makes sense; if junk data is allowed at the beginning of a ZIP file or elsewhere within it, you could delete or update files from a ZIP without having to modify the early parts of the file this way, with the old local file header and data simply becoming junk data while you modify the EOCD and/or append the new version of the file to the end. This could be quite useful when working with ZIP files spread across multiple disks (though I doubt that's as common of a use case now as it must have been when the format was first designed).

With that in mind, it looks like the only valid way to determine the structure of the ZIP file is to find the EOCD record, and then to work from there. The EOCD record will
point to the rest of the central directory, which in turn points to the local file headers and data. There's just one issue: there are at least two ways to look for the EOCD record.

## A truly awful ZIP file

The EOCD record is identified by its magic number. However, it by no means will necessarily be the only occurrence of that magic number in the file: for instance, if another zip is stored uncompressed within the zip, its EOCD record will also be present (albeit pointing to nonsensical offsets, and with an incorrect comment length). So it seems like one approach would be to scan through from the front of the file (or from the maximum-length-of-an-EOCD-record offset from the end of the file, rather) looking for the magic number, and then validate that it's a valid EOCD record that reaches the end of the file.

Of course, you could _also_ scan backwards from the end of the file, looking for the magic number, and then validating that it's followed by a valid EOCD record once you find it. Surely these two approaches would yield the same result, right?

A ZIP file can contain arbitrary junk data at the start, which is necessary to support self-extracting ZIP archives. PKWARE's spec also doesn't seem to place any restrictions on the contents of the ZIP file comment field in the EOCD record, other than the limit on its length, so in theory you could store whatever you wanted to _there_ too. So what would happen if you made a ZIP file with an EOCD record whose comment field contained another ZIP file, such that no matter which EOCD record you find first, you get a valid ZIP file? Something like

```
[files (A)]
[central directory (A)]
[EOCD (A) with comment containing:
    [files (B)]
    [central directory (B)]
    [EOCD (B)]
]
```

Where all the offsets are valid and the like. Making such a file manually isn't that hard; I just took two ZIP files, added the size of the former to all the offsets in the latter's EOCD and central directory headers, and then set the comment length of the former's EOCD to the size of the latter and combined the two. You can download the resulting ZIP file [here](/assets/files/posts/2026-01-29-zip-files/why.zip).

## Implementation details

It would be lovely if everyone had decided to parse this kind of file the same way, but unfortunately that seems to not be the case. The archive contains a single `foo.txt` file if you locate the first EOCD record, and a single `bar.txt` file if you locate the second one. Here's how various implementations treat it:

<table>
    <tbody>
        <tr>
            <th colspan="2"><strong>Command line utilities</strong></th>
        </tr>
        <tr>
            <td><code>unzip</code> (UnZip 6.00)</td>
            <td><code>bar.txt</code></td>
        </tr>
        <tr>
            <td><code>7z</code> (7-Zip 23.01)</td>
            <td><code>foo.txt</code></td>
        </tr>
        <tr>
            <th colspan="2"><strong>Java</strong> (OpenJDK 21.0.9+10-Ubuntu-124.04)</th>
        </tr>
        <tr>
            <td><code>ZipFile</code> API</td>
            <td><code>bar.txt</code></td>
        </tr>
        <tr>
            <td>ZIP-backed <code>FileSystem</code></td>
            <td><code>bar.txt</code></td>
        </tr>
        <tr>
            <td><code>ZipInputStream</code></td>
            <td><code>foo.txt</code></td>
        </tr>
        <tr>
            <th colspan="2"><strong>Python</strong> (3.12.3)</th>
        </tr>
        <tr>
            <td><code>zipfile</code> module</td>
            <td><code>bar.txt</code></td>
        </tr>
        <tr>
            <th colspan="2"><strong>Julia</strong> (1.12.4)</th>
        </tr>
        <tr>
            <td><code>ZipFile.jl</code> (v0.1.0)</td>
            <td><code>bar.txt</code></td>
        </tr>
        <tr>
            <td><code>ZipArchives.jl</code> (v2.6.0)</td>
            <td><code>bar.txt</code></td>
        </tr>
    </tbody>
</table>

The behavior of `ZipInputStream` and its difference from the other java implementations makes some sense: the API has some inherent quirks due to reading a ZIP from a non-seekable stream, where it can't check the EOCD record until it's already provided you with all the entries. The ZIP format seems to be unfriendly to streaming in general; a tradeoff of the ease-of-updating-or-deleting that placing the EOCD record at the end of the file provides, I suppose.

It looks like most implementations are (excluding potential weirdness with approaches that read from streams) working from the end of the file backwards to find the last valid EOCD record. I am somewhat curious why (given that the EOCD record must be at the end of the file, and identifies it as a zip) the magic number wasn't placed at the end of the record and the fields reordered as needed to avoid this sort of ambiguity, but I suppose it's enough of a strange edge case you'd have to try rather hard to run into it.